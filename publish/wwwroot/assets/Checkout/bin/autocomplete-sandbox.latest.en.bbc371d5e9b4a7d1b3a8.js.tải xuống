"use strict";(self.webpackChunkcheckout_web=self.webpackChunkcheckout_web||[]).push([[891],{5003:(e,t,n)=>{var r=n(2924);class o extends Error{constructor(e,t){super(`GraphQL fetch failed with network failure or prevented the request from completing: ${t.message}. headers: ${JSON.stringify(Object.fromEntries(e.entries()))}`),this.headers=e,this.error=t,this.name="AddressValidatorGraphQLFetchNetworkError"}}class s extends Error{constructor(e,t){super(`GraphQL fetch failed with status: ${e}, response: ${t}`),this.status=e,this.response=t,this.name="AddressValidatorHttpError"}}const a={"Content-Type":"application/json",Accept:"application/json"};let i=function(e){return e.Af="AF",e.Ax="AX",e.Al="AL",e.Dz="DZ",e.Ad="AD",e.Ao="AO",e.Ai="AI",e.Ag="AG",e.Ar="AR",e.Am="AM",e.Aw="AW",e.Ac="AC",e.Au="AU",e.At="AT",e.Az="AZ",e.Bs="BS",e.Bh="BH",e.Bd="BD",e.Bb="BB",e.By="BY",e.Be="BE",e.Bz="BZ",e.Bj="BJ",e.Bm="BM",e.Bt="BT",e.Bo="BO",e.Ba="BA",e.Bw="BW",e.Bv="BV",e.Br="BR",e.Io="IO",e.Bn="BN",e.Bg="BG",e.Bf="BF",e.Bi="BI",e.Kh="KH",e.Ca="CA",e.Cv="CV",e.Bq="BQ",e.Ky="KY",e.Cf="CF",e.Td="TD",e.Cl="CL",e.Cn="CN",e.Cx="CX",e.Cc="CC",e.Co="CO",e.Km="KM",e.Cg="CG",e.Cd="CD",e.Ck="CK",e.Cr="CR",e.Hr="HR",e.Cu="CU",e.Cw="CW",e.Cy="CY",e.Cz="CZ",e.Ci="CI",e.Dk="DK",e.Dj="DJ",e.Dm="DM",e.Do="DO",e.Ec="EC",e.Eg="EG",e.Sv="SV",e.Gq="GQ",e.Er="ER",e.Ee="EE",e.Sz="SZ",e.Et="ET",e.Fk="FK",e.Fo="FO",e.Fj="FJ",e.Fi="FI",e.Fr="FR",e.Gf="GF",e.Pf="PF",e.Tf="TF",e.Ga="GA",e.Gm="GM",e.Ge="GE",e.De="DE",e.Gh="GH",e.Gi="GI",e.Gr="GR",e.Gl="GL",e.Gd="GD",e.Gp="GP",e.Gt="GT",e.Gg="GG",e.Gn="GN",e.Gw="GW",e.Gy="GY",e.Ht="HT",e.Hm="HM",e.Va="VA",e.Hn="HN",e.Hk="HK",e.Hu="HU",e.Is="IS",e.In="IN",e.Id="ID",e.Ir="IR",e.Iq="IQ",e.Ie="IE",e.Im="IM",e.Il="IL",e.It="IT",e.Jm="JM",e.Jp="JP",e.Je="JE",e.Jo="JO",e.Kz="KZ",e.Ke="KE",e.Ki="KI",e.Kp="KP",e.Xk="XK",e.Kw="KW",e.Kg="KG",e.La="LA",e.Lv="LV",e.Lb="LB",e.Ls="LS",e.Lr="LR",e.Ly="LY",e.Li="LI",e.Lt="LT",e.Lu="LU",e.Mo="MO",e.Mg="MG",e.Mw="MW",e.My="MY",e.Mv="MV",e.Ml="ML",e.Mt="MT",e.Mq="MQ",e.Mr="MR",e.Mu="MU",e.Yt="YT",e.Mx="MX",e.Md="MD",e.Mc="MC",e.Mn="MN",e.Me="ME",e.Ms="MS",e.Ma="MA",e.Mz="MZ",e.Mm="MM",e.Na="NA",e.Nr="NR",e.Np="NP",e.Nl="NL",e.An="AN",e.Nc="NC",e.Nz="NZ",e.Ni="NI",e.Ne="NE",e.Ng="NG",e.Nu="NU",e.Nf="NF",e.Mk="MK",e.No="NO",e.Om="OM",e.Pk="PK",e.Ps="PS",e.Pa="PA",e.Pg="PG",e.Py="PY",e.Pe="PE",e.Ph="PH",e.Pn="PN",e.Pl="PL",e.Pt="PT",e.Qa="QA",e.Cm="CM",e.Re="RE",e.Ro="RO",e.Ru="RU",e.Rw="RW",e.Bl="BL",e.Sh="SH",e.Kn="KN",e.Lc="LC",e.Mf="MF",e.Pm="PM",e.Ws="WS",e.Sm="SM",e.St="ST",e.Sa="SA",e.Sn="SN",e.Rs="RS",e.Sc="SC",e.Sl="SL",e.Sg="SG",e.Sx="SX",e.Sk="SK",e.Si="SI",e.Sb="SB",e.So="SO",e.Za="ZA",e.Gs="GS",e.Kr="KR",e.Ss="SS",e.Es="ES",e.Lk="LK",e.Vc="VC",e.Sd="SD",e.Sr="SR",e.Sj="SJ",e.Se="SE",e.Ch="CH",e.Sy="SY",e.Tw="TW",e.Tj="TJ",e.Tz="TZ",e.Th="TH",e.Tl="TL",e.Tg="TG",e.Tk="TK",e.To="TO",e.Tt="TT",e.Ta="TA",e.Tn="TN",e.Tr="TR",e.Tm="TM",e.Tc="TC",e.Tv="TV",e.Ug="UG",e.Ua="UA",e.Ae="AE",e.Gb="GB",e.Us="US",e.Um="UM",e.Uy="UY",e.Uz="UZ",e.Vu="VU",e.Ve="VE",e.Vn="VN",e.Vg="VG",e.Wf="WF",e.Eh="EH",e.Ye="YE",e.Zm="ZM",e.Zw="ZW",e.Zz="ZZ",e}({});const d="https://atlas.shopifysvc.com/graphql",c=(i.Ca,i.Us,"elasticsearch"),l="google",S=new Map([["ELASTICSEARCH_AUTOCOMPLETE",c],["GOOGLE_PLACE_AUTOCOMPLETE",l]]);var p=n(6965);class u extends Error{constructor(...e){super(...e),this.name="AutocompletePredictionError"}}const C=new class{constructor({validationEndpoint:e}){this.validationEndpoint=void 0,this.validationEndpoint=e}async validate({address:e,locale:t,matchingStrategy:n},r={}){const i=new Headers({...a,...r.overrideHeaders}),d=await fetch(this.validationEndpoint,{method:"POST",headers:i,body:JSON.stringify({query:"\nquery validation($address: AddressInput!, $locale: String!, $matchingStrategy: MatchingStrategy) {\n  validation(address: $address, locale: $locale, matchingStrategy: $matchingStrategy) {\n    validationScope\n    locale\n    fields {\n      name\n      value\n    }\n    concerns {\n      fieldNames\n      code\n      type\n      typeLevel\n      suggestionIds\n      message\n    }\n    id\n    suggestions {\n      id\n      address1\n      address2\n      city\n      zip\n      provinceCode\n      province\n      countryCode\n    }\n  }\n}\n",operationName:"validation",variables:{address:e,locale:t,matchingStrategy:n}})}).catch((e=>e));if(d instanceof Error)throw new o(i,d);if(!d.ok)throw new s(d.status,await d.text());const{data:c,errors:l}=await d.json();return{data:c.validation,errors:l}}}({validationEndpoint:d});(0,r.dg)({addEventListener:window.addEventListener.bind(window),removeEventListener:window.removeEventListener.bind(window),postMessage(e,t){window.parent.postMessage(e,"*",t)}}).expose({search:async(e,t,n)=>{const r={query:e,countryCode:t.countryCode,location:t.location,locale:t.locale,sessionToken:t.requestToken};[c,l].includes(String(n))&&(r.adapterOverride=n);const o=(0,p.zO)(),s=await fetch(d,{method:"POST",headers:{"Content-Type":"application/json","X-Shop-Id":t.shopId,"X-Client-Request-Id":t.sourceId},body:JSON.stringify({query:"\n  query predictions($query: String, $countryCode: AutocompleteSupportedCountry!, $locale: String!, $location: LocationInput, $sessionToken: String!, $adapterOverride: String) {\n    predictions(query: $query, countryCode: $countryCode, locale: $locale, location: $location, sessionToken: $sessionToken, adapterOverride: $adapterOverride) {\n      addressId\n      description\n      completionService\n      matchedSubstrings {\n        length\n        offset\n      }\n    }\n  }\n",variables:r})}),a=(0,p.zO)(),i=await s.json();if(!i.data)throw new u(`No data returned from autocomplete query ${JSON.stringify(i)}`);return{data:i.data.predictions,duration:{start:o,end:a}}},fetchAddress:async(e,t)=>{const n={addressId:e,locale:t.locale,sessionToken:t.requestToken,adapterOverride:S.get(t.completionService)},r=await fetch(d,{method:"POST",headers:{"Content-Type":"application/json","X-Shop-Id":t.shopId,"X-Client-Request-Id":t.sourceId},body:JSON.stringify({query:"\n  query address($addressId: String!, $locale: String!, $sessionToken: String!, $adapterOverride: String) {\n    address(id: $addressId, locale: $locale, sessionToken: $sessionToken, adapterOverride: $adapterOverride) {\n      address1\n      address2\n      city\n      country\n      countryCode\n      province\n      provinceCode\n      zip\n      latitude\n      longitude\n    }\n  }\n",variables:n})}),{data:{address:o}}=await r.json(),{address1:s,address2:a,city:i,countryCode:c,provinceCode:l,zip:p,latitude:u,longitude:C}=o,h={latitude:u,longitude:C};return{postalCode:p,city:i,address1:s,address2:a,countryCode:c,zoneCode:l,coordinates:h.latitude&&h.longitude?h:void 0}},validation:async(e,t,n,r)=>{const o={"X-Shop-Id":r?.shopId||"","X-Client-Request-Id":r?.sourceId||""};return C.validate({address:e,locale:t,matchingStrategy:n},{overrideHeaders:o})}})}},e=>{e.O(0,[924,965],(()=>(5003,e(e.s=5003)))),e.O()}]);